{% extends "base.html" %}
{%  block app_content %}
    <h2 style ="text-align:center">Jordan Bailey, University at Buffalo</h2>
    <h4>HTML</h4>
 <p style ="text-indent:50px">  The HTML is created by rendering templates using the Jinja2 template engine.  To handle the forms, I used the flask-wtf extension which is a wrapper of WTForms. This allowed me to create the forms as classes in python and apply custom validation easily. For example, the registration form had a custom validator that checked to see if the username or email was already taken by querying the database. The styling was done using flask-bootstap, which contained functions to automatically style WTForms. It also gave a base template with the Bootstrap CSS  and JS built in that I could extend, allowing me to import each section of the webpage in content blocks.</p>

<h4>Database</h4>
 <p style ="text-indent:50px"> I used a simple SQLite database (one file) to handle the data, and used the Flask-SQLAlchemy extension to make working with the database easier. This also provides flexibility if I wanted to use a server like PostgreSQL in the future, as I could use the models created with SQLAlchemy to make the transition. Since the database tables changed a lot during the creation of the website, I used flask-migrate to update the structure of the actual database and keep it in synch with the state of all my models with SQLAlchemy. The database instance created by SQLAlchemy allowed me to commit and add to the database within the code through contexts of a session, exposed through the object db.session. The backref feature of SQLAlchemy made handling relationships extremely convenient, as it exposed a high level virtual field to get all the data on the other side of the relationship. For example, user1.posts would get all the posts written by user1, even though User and Posts are separate tables.</p>

    <h4>User State</h4>
 <p style ="text-indent:50px"> To deal with keeping track of logged in state, I used the extension flask-login. This was a good alternative to creating sessions for each user myself or using something like JWT. This is because flask-login gives you the option to store a unique identifier in Flask’s user session, and then assign a user_loader function that loads a resource given this id on every request to a webpage. I made the unique identifier the user’s ID. This would cause the User to be loaded through the user_loader function on each request. I also used the remember-me feature of flask-login, which stores a cookie that contains the unique identifier when the user closes their browser.</p>

    <h4>Secure Emails</h4>
 <p style ="text-indent:50px">For the password reset feature, I used flask-mail and pyjwt which gave a way to work with JSON web tokens. When a user requests a password reset, an email is sent to the email address they entered containing a token. This token contains the id associated with the user with that email. When the user clicks the link in their email, the server first verifies if the token has a valid signature, and then loads the user with the id in the token and serves the user a password reset form. Each email is sent on a background thread that uses the same application context as the main thread.</p>

    <h4>Language and Timezones</h4>
 <p style ="text-indent:50px">  To handle language and time zones, I used flask-moment and flask-babel. This makes the website appear in Spanish if Spanish is the User’s preferred language. Flask-moment made it easy to work with the moment.js library in my templates. The moment() function takes a datetime object and converts it to the user’s time zone. Each post is stored with a timestamp in UTC and then converted to the user’s time zone using moment() client-side. The painful process of making the website available in Spanish used flask-babel. A function is executed before every request that returns the preferred language of the User. Babel translates all the text wrapped in _(‘text’) to this language. For text that the user see’s that’s set outside the context of a request, I used the function  _l(‘text’), which delayed the evaluation of the text.</p>

     <h4>Translations</h4>
 <p style ="text-indent:50px">I used the library guess_language_spirit and the Microsoft Translator API for the translate feature that appears under each post written in a different language than the current user’s. To implement this, each blog is stored with a language field, and that language field is compared to the current user’s language (obtained via flask-babel). If the language is different, a translate link will appear, that when clicked will tell the server to request a translation of the blog post from Microsoft Translator, which will return the translation to the client.</p>

    <h4>Search Functionality</h4>
 <p style ="text-indent:50px">I used elasticsearch to implement the searching functionality. The search box that appears in the navbar searches through every post, and returns the posts that match the query. Each query in the search box is sent to the “/search” route that triggers a class method on the Posts model (a representation of the post db table). This method takes the query and calls an elasticsearch query, which then returns all the posts that match the query. These posts are then displayed to the user in a separate html page. Every post is indexed and unindexed (registered with elasticsearch) on every commit to the database which ensures the database and elasticsearch data stay in synch. This is done through assigning event handlers to before_commit() and after_commit() methods of SQLAlchemy.</p>

     <h4>API</h4>
 <p style ="text-indent:50px">I implemented a users API to allow the client to work with the data directly. This was done by adding a function to the User model that displayed the data of a user in JSON, and by adding routes that allow the client to interact with this data. The API endpoints offer options to view a specific user, view all users, view the followers/following of a user, and register/modify a user. To secure these endpoints I used flask-httpauth, which allowed me to decorate the view functions with login_required and token_required restrictions. To get a token, the user needs to send a post request to the “/tokens” route with their credentials. Then the client can send a request to any of the API endpoints, as long as the token is included in the Authorization header.</p>

    <h4>Application Structure</h4>
 <p style ="text-indent:50px">I structured the project by putting the application in a package, and dividing the related sections of the website into blueprints. Each blueprint is just a package that contains the views, functions, and files associated with a certain component of the website. Each blueprint is inactive until you register it with the application. I created blueprints for authentication, errors, the user functionality, and the API. Now if I wanted to make another website, I could easily take out a blueprint from this site, and be able to register it with the new app without changing any code. </p>




{% endblock %}
